<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <!-- Viewportの幅は実際の解像度ではなく端末やブラウザに合わせた値を返します。 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TBW2020 Display System</title>

    <!-- Web Appをホーム画面にインストールした際の挙動を定義するmetaタグ -->
    <!-- iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- Chrome for Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <!-- Chrome、Opera、Firefox、Samsung(manifestでの対応の場合) -->
    <link rel="manifest" href="./manifest.json">

    <!-- cssの読み込み -->
    <!-- main.css -->
    <style type="text/css">
      body
      {
          font-family: monospace;

          background-color: black;
          /* font-family: monospace; */
      }

      /* 高度バーのアニメーション */
      .bar
      {
          transition-timing-function: ease-out;
          transition-duration: .5s;
          transition-property: height y;
      }

      .bar-text
      {
          font-family: Arial, Helvetica, sans-serif;

          color: white;

          stroke: none;
          text-anchor: start;
          /* 横方向の位置 */
      }

      /* Map */
      .map
      {
          position: relative;
      }

      .map > *
      {
          position: absolute;
      }

      button
      {
          font-size: 2vh;
          font-weight: 700;

          width: 100vw;
          height: 5vh;
      }

      /* 全画面表示時の挙動 */
      /* ユーザーがホーム画面からサイトを起動した場合は、display-mode メディアクエリがウェブアプリマニフェストで定義した状態に設定されます。完全な全画面表示の場合は、次のようになります。 */
      @media all and (display-mode: fullscreen)
      {
          #goFS
          {
              /* display: none; */
          }
      }

    </style>
    <!-- structure.css -->
    <style type="text/css">
      /* CSS Custom Property */
      :root
      {
          --window-width: 100vw;
          --window-height: 100vh;
      }

      /* ブラウザで初期設定されている余白を消す */
      *
      {
          margin: 0;
          padding: 0;
      }

      /* 全体を覆うcontainer */
      #container
      {
          display: grid;
          /* width: 100vw;
                                                                                                                                                                                                                                                    height: 100vh; */

          width: var(--window-width);
          height: var(--window-height);
      }

      /* 各要素を囲むwrapper */
      .wrapper
      {
          position: relative;

          display: none;
      }

      /* ラベル */
      .label
      {
          /* font-size: 2vh; */
          font-size: calc(var(--window-height) * .02);

          position: absolute;
          top: 0;
          left: 0;

          color: white;
      }

      /* 高度Bar */
      #alt_barmeter_wrapper
      {
          position: relative;
      }

      #alt_barmeter_wrapper > .present_val
      {
          position: absolute;
          z-index: 10;
      }

      .tachometer
      {
          position: absolute;
          bottom: 0;

          display: block;

          justify-self: center;
      }

      /* グラフ */
      #graph_wrapper
      {
          background-color: gray;
      }

      /* 何も表示しない */
      /* @media screen and (max-width: 320px)
                                                                                                                                                                        {
                                                                                                                                                                        } */

      /* スマホ版 */
      @media screen and (max-width: 320px)
      {
          #container
          {
              /* grid-template-rows: minmax(calc(100vh - 50vw), 70vh) minmax(60px, 50vw);
                                                                                                                                                                                                                                                        grid-template-columns: 1fr 2fr 50vw; */
              grid-template-rows: minmax(calc(var(--window-height) - (var(--window-width)/2)), calc(var(--window-height)*.7)) minmax(60px, calc(var(--window-width) / 2));
              grid-template-columns: 1fr 2fr 50vw;
              grid-template-areas: 'areaA areaB areaB'
              'areaC areaC areaD';
          }

          #alt_barmeter_wrapper
          {
              display: block;

              grid-area: areaA;
          }

          #map_wrapper
          {
              display: block;

              grid-area: areaB;
          }

          #aspd_tachometer_wrapper
          {
              display: block;

              grid-area: areaC;
          }

          #rpm_tachometer_wrapper
          {
              display: block;

              grid-area: areaD;
          }

          /* ラベルを非表示にする */
          .label
          {
              display: none;
          }
      }

      /* タブレット版 */
      @media screen and (max-width: 960px)
      {
          #container
          {
              /* grid-template-rows: 1fr calc(33vw + 30px) minmax(100px, 20vh);
                                                                                                                                                                                                                                                        grid-template-columns: 10.4vw 23vw 22.3vw 11vw 33.3vw; */
              grid-template-rows: 1fr calc(var(--window-width) * .33 + 30px) minmax(100px, calc(var(--window-height) * .2));
              grid-template-columns: calc(var(--window-width) * .104) calc(var(--window-width) * .23) calc(var(--window-width) * .223) calc(var(--window-width) * .11) calc(var(--window-width) * .333);
              grid-template-areas: 'areaA areaB areaB areaC areaC'
              'areaD areaD areaE areaE areaF'
              'areaG areaG areaG areaG areaG';
          }

          #alt_barmeter_wrapper
          {
              display: block;

              grid-area: areaA;
          }

          #map_wrapper
          {
              display: block;

              grid-area: areaB;
          }

          #posture_wrapper
          {
              display: block;

              grid-area: areaC;
          }

          #aspd_tachometer_wrapper
          {
              display: block;

              grid-area: areaD;
          }

          #gspd_tachometer_wrapper
          {
              display: block;

              grid-area: areaE;
          }

          #rpm_tachometer_wrapper
          {
              display: block;

              grid-area: areaF;
          }

          #graph_wrapper
          {
              display: block;

              grid-area: areaG;
          }

          /* ラベル */
          .label
          {
              display: block;
          }
      }

      /* PC版 */
      @media screen and (min-width: 960px)
      {
          #container
          {
              /* grid-template-rows: 33vh 33vh 34vh;
                                                                                                                                                                                                                                                        grid-template-columns: minmax(50px, 10vw) 1fr 1fr minmax(100px, 33vh); */
              grid-template-rows: calc(var(--window-height) * .33) calc(var(--window-height) * .33) calc(var(--window-height) * .34);
              grid-template-columns: minmax(50px, calc(var(--window-width) * .1)) 1fr 1fr minmax(100px, calc(var(--window-height) * .33));
              grid-template-areas: 'areaA areaB areaC areaD'
              'areaA areaB areaC areaE'
              'areaF areaF areaF areaG';
          }

          #alt_barmeter_wrapper
          {
              display: block;

              grid-area: areaA;
          }

          #map_wrapper
          {
              display: block;

              grid-area: areaB;
          }

          #posture_wrapper
          {
              display: block;

              grid-area: areaC;
          }

          #aspd_tachometer_wrapper
          {
              display: block;

              grid-area: areaD;
          }

          #gspd_tachometer_wrapper
          {
              display: block;

              grid-area: areaE;
          }

          #graph_wrapper
          {
              display: block;

              grid-area: areaF;
          }

          #rpm_tachometer_wrapper
          {
              display: block;

              grid-area: areaG;
          }
      }

    </style>
  </head>

  <body>
    <div id="container">

      <!-- 高度表示バー -->
      <div id="alt_barmeter_wrapper" class="wrapper">
        <!-- 現在高度の数値表示 -->
        <div class="present_val bar-text">
          <span>2.98</span><span>m</span>
        </div>

        <!-- バー表示 -->
        <svg viewBox="0 -1200 400 1200" id="alt_barmeter">
          <defs>
            <style>
              .bar-text
              {
                  font-family: Arial, Helvetica, sans-serif;

                  fill: white;
                  stroke: none;
                  text-anchor: start;
              }

            </style>
          </defs>

          <!-- Bar背景の白色部分 -->
          <rect x="0" y="-1150" width="400" height="1150" fill="white"></rect>
          <!-- Bar部分 -->
          <rect x="0" y="-600" width="400" height="600" fill="tomato" class="bar"></rect>
          <!-- Bar周辺を囲む黒色部分。これを上から被せることによって、Barの形を実現している。 -->
          <path d="" fill-rule="evenodd" fill="black" stroke="none" class="base_barmeter"></path>
          <!-- 目盛り -->
          <g class="scale">
            <!-- 目盛り線 -->
            <g stroke="black" stroke-width="5" class="scale_lines">
              <line x1="0" y1="-100" x2="400" y2="-100"></line>
              <line x1="0" y1="-150" x2="400" y2="-150" stroke-dasharray="5 5" stroke-dashoffset="2.5"></line>
              <line x1="0" y1="-950" x2="400" y2="-950" stroke-dasharray="5 5" stroke-dashoffset="2.5"></line>
              <line x1="0" y1="-1000" x2="400" y2="-1000"></line>
            </g>
            <!-- 目盛り数値 -->
            <!-- dominant-baselineでy=0の位置を指定できる -->
            <g class="scale_texts bar-text" font-size="30" dominant-baseline="text-before-edge">
              <text x="" y="-100">1.0</text>
              <text x="" y="-150">1.5</text>
              <text x="" y="-950">9.5</text>
              <text x="" y="-1000">10.0</text>
            </g>
          </g>
          <!-- 現在値 -->
          <!-- <text class="present_val bar-text" x="" y="-1020" font-size="">
            <tspan>2.98</tspan>
            <tspan>m</tspan>
          </text> -->
        </svg>
      </div>

      <!-- 対気速度 -->
      <div id="aspd_tachometer_wrapper" class="wrapper">
        <div id="aspd_label" class="label">対気速度</div>
        <svg width="400" height="400" viewBox="-100 -100 200 200" id="aspd_tachometer" class="tachometer">
          <defs>
            <style>
              .tacho-text
              {
                  font-family: Arial, Helvetica, sans-serif;

                  text-anchor: middle;
                  fill: white;
                  stroke: none;
              }

            </style>
          </defs>

          <path d="" fill="white" class="base_arc"></path>
          <path d="" fill="skyblue" class="arc">
            <!-- <animate attributeName="d" dur="2.5s" from="" to="" repeatCount="indefinite"> -->
          </path>
          <circle cx="0" cy="0" r="80" fill="black"></circle>
          <!-- 目盛り -->
          <g class="scale">
            <!-- 目盛り線 -->
            <g stroke="black" stroke-width="4" class="scale_lines">
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
            </g>
          </g>
          <text x="0" y="10" class="tacho-text present_val" font-size="60">50.0</text>
          <text x="0" y="50" class="tacho-text" font-size="30">m/s</text>
        </svg>
      </div>

      <!-- 対地速度 -->
      <div id="gspd_tachometer_wrapper" class="wrapper">
        <div id="gspd_label" class="label">対地速度</div>
        <svg width="400" height="400" viewBox="-100 -100 200 200" id="gspd_tachometer" class="tachometer">
          <defs>
            <style>
              .tacho-text
              {
                  font-family: Arial, Helvetica, sans-serif;

                  text-anchor: middle;
                  fill: white;
                  stroke: none;
              }

            </style>
          </defs>

          <path d="" fill="white" class="base_arc"></path>
          <path d="" fill="skyblue" class="arc">
            <!-- <animate attributeName="d" dur="2.5s" from="" to="" repeatCount="indefinite"> -->
          </path>
          <circle cx="0" cy="0" r="80" fill="black"></circle>
          <!-- 目盛り -->
          <g class="scale">
            <!-- 目盛り線 -->
            <g stroke="black" stroke-width="4" class="scale_lines">
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
            </g>
          </g>
          <text x="0" y="10" class="tacho-text present_val" font-size="60">50.0</text>
          <text x="0" y="50" class="tacho-text" font-size="30">m/s</text>
        </svg>
      </div>

      <!-- 回転数 -->
      <div id="rpm_tachometer_wrapper" class="wrapper">
        <div id="rpm_label" class="label">回転数</div>
        <svg width="400" height="400" viewBox="-100 -100 200 200" id="rpm_tachometer" class="tachometer">
          <defs>
            <style>
              .tacho-text
              {
                  font-family: Arial, Helvetica, sans-serif;

                  text-anchor: middle;
                  fill: white;
                  stroke: none;
              }

            </style>
          </defs>

          <path d="" fill="white" class="base_arc"></path>
          <path d="" fill="skyblue" class="arc"></path>
          <circle cx="0" cy="0" r="80" fill="black"></circle>
          <!-- 目盛り -->
          <g class="scale">
            <!-- 目盛り線 -->
            <g stroke="black" stroke-width="4" class="scale_lines">
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
              <line x1="0" y1="0" x2="0" y2="0"></line>
            </g>
          </g>
          <text x="0" y="10" class="tacho-text present_val" font-size="60">50.0</text>
          <text x="0" y="50" class="tacho-text" font-size="30">r/min</text>
        </svg>
      </div>

      <!-- map -->
      <div id="map_wrapper" class="wrapper">
        <div class="map" id="map">
          <img src="./img/ootone.png" class="map_layer">
          <svg class="points_layer" expanded="true">
            <defs>
              <style>
                circle
                {
                    fill: rgb(150, 150, 150);
                    stroke: white;
                }

                circle:last-of-type
                {
                    fill: red;
                    stroke: none;
                }

                .present_effect
                {
                    fill: white;
                    stroke: none;
                }

              </style>
            </defs>
            <g class="points">
            </g>
            <circle class="present_effect" r="0">
              <animate attributeName="r" begin="0s" dur="1.5s" repeatCount="indefinite" from="4" to="15" />
              <animate attributeName="fill-opacity" begin="0s" dur="1.5s" repeatCount="indefinite" from="1" to=".5" />
            </circle>
          </svg>
        </div>
      </div>

      <!-- 姿勢 -->
      <div id="posture_wrapper" class="wrapper"></div>

      <!-- グラフ -->
      <div id="graph_wrapper" class="wrapper"></div>
    </div>

    <!-- 全画面表示用のボタン -->
    <button id="goFS">Fullscreen</button>
    <!-- アラームON/OFFボタン -->
    <!-- ChromeとSafariのメディア要素（<video>, <audio>）の自動再生におけるポリシーの変更されaudioタグの自動再生ができなくなりました。 -->
    <button id="alert_switch" type="button">Alert ON</button>

    <!-- アラート音 -->
    <!-- preloadで予めロード。loopはスマホブラウザだと動かないという情報もあり。loopは論理型の属性 -->
    <audio id="warning_sound" preload="auto" loop>
      <!-- <source>タグは、動画や音声などのメディアファイルのURLや種類を指定する際に、<video>～</video>などのメディア要素の中で子要素として使用します。 <source>は、それ自身では何も表しません。 -->
      <!-- wavファイルが再生できないデバイスの場合、mp3ファイルが再生される。 -->
      <source src="./sounds/warning.wav" type="audio/wav">
      <source src="./sounds/warning.mp3" type="audio/mp3">
    </audio>
    <audio id="danger_sound" preload="auto" loop>
      <source src="./sounds/danger.wav" type="audio/wav">
      <source src="./sounds/danger.mp3" type="audio/mp3">
    </audio>

    <!-- type="module" さえあれば、HTMLに埋め込まれたスクリプトでモジュールをインポートして使うこともできます。 -->
    <!-- ただし、このままではCORSエラーが発生する。なぜなら、多くのブラウザでは、JavaScriptを使用してローカルファイルシステム上のファイルにアクセスできません（HTMLドキュメントがローカルファイルシステム上にもある場合でも）。 -->
    <!-- importで他のJSファイルを読み込むことが、これに当たるようである。 -->
    <!-- 戦略としては、複数scriptタグを用意する方法で行こうと思う。 -->
    <script src="./js/threeJS/three.min.js"></script>
    <script src="./js/threeJS/OrbitControls.js"></script>

    <!-- generalFuncs.js -->
    <script type="text/javascript">
      'use strict';

      class GeneralFuncs {
        static is_playing_alert = { altitude: false, map: false };
        static warning_sound = document.getElementById('warning_sound');
        static danger_sound = document.getElementById('danger_sound');
        static is_ok_playing_alert = false;

        constructor() {
          this.normal_color = 'skyblue';
          this.warning_color = 'orange';
          this.danger_color = 'tomato';
        }

        normalizeValue(val, maxVal, minVal) {
          if (val > maxVal)
            return maxVal;
          else if (val < minVal)
            return minVal;
          else
            return val;
        }

        playAlert(alert_type, target) {
          if (GeneralFuncs.is_ok_playing_alert) {
            switch (alert_type) {
              case 'warning':
                // 危険音がなっていたら、再生しない
                if (GeneralFuncs.warning_sound.paused && GeneralFuncs.danger_sound.paused) {
                  GeneralFuncs.warning_sound.play();
                  GeneralFuncs.is_playing_alert[target] = true;
                }
                break;
              case 'danger':
                if (GeneralFuncs.danger_sound.paused) {
                  this.pauseAlert('warning');
                  GeneralFuncs.danger_sound.play();
                  GeneralFuncs.is_playing_alert[target] = true;
                }
                break;
              default:
                break;
            }
          }
        }

        pauseAlert(alert_type, target) {
          // 他のtergetのalertが再生されていれば、停止しない
          const keys = Object.keys(GeneralFuncs.is_playing_alert).filter(val => val != target);
          for (const key of keys) {
            if (GeneralFuncs.is_playing_alert[key] === true)
              return;
          }

          switch (alert_type) {
            case 'warning':
              if (!GeneralFuncs.warning_sound.paused) {
                GeneralFuncs.warning_sound.pause();
                GeneralFuncs.is_playing_alert[target] = false;
              }
              break;
            case 'danger':
              if (!GeneralFuncs.danger_sound.paused) {
                GeneralFuncs.danger_sound.pause();
                GeneralFuncs.is_playing_alert[target] = false;
              }
              break;
            default:
              break;
          }
        }

        checkAlert(val, target_node, warning_val_ranges, danger_val_ranges, mode) {
          switch (mode) {
            case 'altitude':
              // 警告範囲のチェック
              for (const warning_val_range of warning_val_ranges) {
                if (val >= warning_val_range.min && val <= warning_val_range.max) {
                  this.pauseAlert('danger', 'altitude');
                  this.playAlert('warning', 'altitude');
                  target_node.setAttribute('fill', this.warning_color);
                  return;
                }
              }

              // 危険範囲のチェック
              for (const danger_val_range of danger_val_ranges) {
                if (val >= danger_val_range.min && val <= danger_val_range.max) {
                  this.pauseAlert('warning', 'altitude');
                  this.playAlert('danger', 'altitude');
                  target_node.setAttribute('fill', this.danger_color);
                  return;
                }
              }

              // 通常時
              this.pauseAlert('warning', 'altitude');
              this.pauseAlert('danger', 'altitude');
              target_node.setAttribute('fill', this.normal_color);
              break;

            case 'map':
              // 警告範囲のチェック
              for (const warning_val_range of warning_val_ranges) {
                let flag = 1;
                // r,g,b,aを取得する
                for (const key of Object.keys(warning_val_range)) {
                  // 一つでも範囲から外れるものがあれば、警告対象から外す
                  if (!(val[key] >= warning_val_range[key].min && val[key] <= warning_val_range[key].max)) {
                    flag = 0;
                    break;
                  }
                }

                if (flag === 1) {
                  this.pauseAlert('danger', 'map');
                  this.playAlert('warning', 'map');
                  // target_node.setAttribute('fill', this.warning_color);
                  return;
                }
              }

              // 危険範囲のチェック
              // console.log(warning_val_ranges);
              // console.log(danger_val_ranges);
              // console.log(val);
              for (const danger_val_range of danger_val_ranges) {
                let flag = 1;
                // r,g,b,aを取得する
                for (const key of Object.keys(danger_val_range)) {
                  // 一つでも範囲から外れるものがあれば、警告対象から外す
                  if (!(val[key] >= danger_val_range[key].min && val[key] <= danger_val_range[key].max)) {
                    flag = 0;
                    break;
                  }
                }

                if (flag === 1) {
                  this.pauseAlert('warning', 'map');
                  this.playAlert('danger', 'map');
                  // target_node.setAttribute('fill', this.warning_color);
                  return;
                }
              }

              // 通常時
              this.pauseAlert('warning', 'map');
              this.pauseAlert('danger', 'map');
              // target_node.setAttribute('fill', this.normal_color);
              break;

            default:
              break;
          }
        }
      }
    </script>

    <!-- barmeter.js -->
    <script type="text/javascript">
      'use strict';

      // barmeter_node_id:"barmeter"
      class BarMeter extends GeneralFuncs {
        constructor(barmeter_node_id, barmeter_wrapper_node_id) {
          // 継承したクラスのコンストラクタは super(...) を呼び出し、(!) this を使う前にそれを行わなければなりません。
          /* 
            JavaScriptでは、“継承しているクラスのコンストラクタ関数” とその他すべてで区別があります。継承しているクラスでは、該当するコンストラクタ関数は特別な内部プロパティ [[ConstructorKind]]:"derived" が付けられます。
            違いは:
            ・通常のコンストラクタを実行するとき、this として空のオブジェクトを作り、それを続けます。
            ・しかし、派生したコンストラクタが実行されると、そうは実行されません。親のコンストラクタがこのジョブを実行することを期待しています。
            なので、もし独自のコンスタクタを作っている場合には、super を呼ばないといけません。なぜなら、そうしないとそれを参照する this を持つオブジェクトは生成されないからです。 結果、エラーになるでしょう。
            https://ja.javascript.info/class-inheritance
          */
          super();
          // 最も外側のsvgに指定されているidを格納
          this.barmeter_node_id = barmeter_node_id;
          this.barmeter_wrapper_node_id = barmeter_wrapper_node_id;
          this.init();
        }

        init() {
          // width, heightを取得
          const barmeter_wrapper_node = document.getElementById(this.barmeter_wrapper_node_id);
          this.width = barmeter_wrapper_node.clientWidth;
          this.height = barmeter_wrapper_node.clientHeight;

          // 定数の定義
          this.maxVal = 12; // バーが表示できる最大値
          this.minVal = 0; // それの最小値
          this.minBarWidth = 30; // 最小Bar横幅(px)
          this.warning_val_ranges = [{ min: 1.0, max: 1.5 }, { min: 9.5, max: 10.0 }];
          this.danger_val_ranges = [{ min: this.minVal, max: 1.0 }, { min: 10.0, max: this.maxVal }];

          // SVG全体の定義
          const barmeter = window.document.getElementById(this.barmeter_node_id);
          const viewBox_height = Math.abs(this.maxVal - this.minVal) * 100; // ->11 これを100倍して、1100。
          const viewBox_width = viewBox_height / this.height * this.width;

          // svgの属性の設定
          // https://lucklog.info/svg-verification-viewbox-width-height2/
          // https://qiita.com/takeshisakuma/items/a6a06902e955acad5c99#preserveaspectratio%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AEmeet%E3%81%A8slice%E3%81%AE%E6%AF%94%E8%BC%83
          barmeter.setAttribute('width', this.width);
          barmeter.setAttribute('height', this.height);
          // barmeter.setAttribute('style', `height: ${this.height}px;`);
          barmeter.setAttribute('viewBox', `0 ${-viewBox_height} ${viewBox_width} ${viewBox_height}`);

          // Bar部分の定義
          this.bar_width = Math.max(this.width / 3, this.minBarWidth) * (viewBox_width / this.width); // Barの横幅
          this.r = this.bar_width / 2; // Bar半円部分の半径
          this.bar = window.document.querySelector(`#${this.barmeter_node_id} > .bar`); // Bar部分を取得
          // 背景とバーになるrect要素の大きさの定義
          const rects = barmeter.getElementsByTagName('rect');
          rects[0].setAttribute('y', -viewBox_height); // rect[0]: 背景rect
          rects[0].setAttribute('height', viewBox_height);
          for (const rect of rects) {
            rect.setAttribute('width', this.bar_width);
          }

          // barの形を生成するための型
          // 小文字：直前座標からの相対座標。大文字：絶対座標
          const base_barmeter = window.document.querySelector(`#${this.barmeter_node_id} > .base_barmeter`);
          const draw_settings = `
                M 0 ${-viewBox_height} h ${viewBox_width} v ${viewBox_height} h ${-viewBox_width} Z
                m 0 ${this.r}
                a ${this.r} ${this.r} 0 0 1 ${2 * this.r} 0
                l 0 ${viewBox_height - 2 * this.r}
                a ${this.r} ${this.r} 0 0 1 ${-2 * this.r} 0
                z 
            `;
          base_barmeter.setAttribute('d', draw_settings);

          // 目盛り線の長さの定義
          for (const scale_line of window.document.querySelector(`#${this.barmeter_node_id} > .scale > .scale_lines`).children) {
            scale_line.setAttribute('x2', this.bar_width);
          }
          // 目盛り文字の定義
          for (const scale_text of window.document.querySelector(`#${this.barmeter_node_id} > .scale > .scale_texts`).children) {
            scale_text.setAttribute('x', this.bar_width + 5);
          }

          // 現在値を表示する領域
          const present_val_left = (this.bar_width + 5) * (this.width / viewBox_width); // px
          const present_val_top = 0;
          this.present_val = window.document.querySelector(`#${this.barmeter_wrapper_node_id} > .present_val`);
          // 現在値を表示する領域の位置を指定
          this.present_val.setAttribute('style', `top: ${present_val_top}px; left: ${present_val_left}px;`);
          // 現在値の数値のフォントサイズを指定
          const val_font_size = (viewBox_height - 1000) * (this.width / viewBox_width);
          this.present_val.children[0].setAttribute('style', `font-size: ${val_font_size}px;`);
          this.present_val.children[1].setAttribute('style', `font-size: ${val_font_size * 0.6}px;`);

          // バーの高さを計算
          this.tmpY = (tmp, max, min) => -((tmp - min) / (max - min)) * viewBox_height;
        }

        updateValue(val) {
          val = this.normalizeValue(val, this.maxVal, this.minVal); // 値の正規化
          this.checkAlert(val, this.bar, this.warning_val_ranges, this.danger_val_ranges, 'altitude');

          this.present_val.children[0].textContent = val.toFixed(2); // 数値部の表示
          // Barの表示
          this.bar.setAttribute('y', this.tmpY(val, this.maxVal, this.minVal));
          this.bar.setAttribute('height', -this.tmpY(val, this.maxVal, this.minVal));
        }
      }
    </script>

    <!-- tachometer.js -->
    <script type="text/javascript">
      'use strict';

      class TachoMeter extends GeneralFuncs {
        constructor(tachometer_node_id, tachometer_wrapper_node_id, maxVal = 60, minVal = 0) {
          super();
          this.tachometer_node_id = tachometer_node_id;
          this.tachometer_wrapper_node_id = tachometer_wrapper_node_id;
          this.maxVal = maxVal;
          this.minVal = minVal;
          this.init();
        }

        init() {
          // width, heightを設定
          const tachometer_wrapper_node = document.getElementById(this.tachometer_wrapper_node_id);
          const tachometer_size = Math.min(tachometer_wrapper_node.clientWidth, tachometer_wrapper_node.clientHeight);
          this.width = tachometer_size;
          this.height = tachometer_size;

          this.initAng = Math.PI / 6; // 最小値・最大値の時の角度
          this.r = 95;
          const base_r = 100;

          // 要素の取得
          const tachometer = window.document.getElementById(this.tachometer_node_id);
          const base_arc = window.document.querySelector(`#${this.tachometer_node_id} > .base_arc`);
          this.arc = window.document.querySelector(`#${this.tachometer_node_id} > .arc`);
          this.arc_animation = window.document.querySelector(`#${this.tachometer_node_id} > .arc > animate`);
          this.present_val = window.document.querySelector(`#${this.tachometer_node_id} > .present_val`);

          const start_point_y = base_r * Math.cos(this.initAng);
          // viewBoxの設定
          tachometer.setAttribute('viewBox', `-100 -100 200 ${base_r + start_point_y}`);
          // 大きさの設定
          tachometer.setAttribute('width', this.width);
          tachometer.setAttribute('height', `${this.height * ((base_r + start_point_y) / (base_r * 2))}`);

          // 土台となる扇型の設定
          // d="M{中心座標} L{円弧始め座標} A{半径} {回転角（傾き）} {if 180度以下 0 else 1} {if 反時計回り 0 else 1} {円弧終り座標}z"
          const base_settings = `M0,0 L${-base_r * Math.sin(this.initAng)},${base_r * Math.cos(this.initAng)} A${base_r},${base_r} 0 1,1 ${base_r * Math.sin(this.initAng)},${base_r * Math.cos(this.initAng)}z`;
          base_arc.setAttribute('d', base_settings);

          // 目盛り線の設定
          const interval_angle = (2 * Math.PI - 2 * this.initAng) / 6;
          // childNodes の代わりに、childrenを使うと、TextNode は含まない、要素ノードだけのcollectionが返されます。
          const scale_lines = window.document.querySelector(`#${this.tachometer_node_id} > .scale > .scale_lines`).children;
          for (let i = 0; i < scale_lines.length; i++) {
            const angle = this.initAng + interval_angle * (i + 1);
            const x1 = base_r * Math.sin(angle);
            const y1 = base_r * Math.cos(angle);
            const x2 = this.r * Math.sin(angle);
            const y2 = this.r * Math.cos(angle);
            scale_lines[i].setAttribute('x1', x1);
            scale_lines[i].setAttribute('y1', y1);
            scale_lines[i].setAttribute('x2', x2);
            scale_lines[i].setAttribute('y2', y2);
          }

          // 値による角度を計算する
          this.calcAngle = (tmp, max, min) => ((tmp - min) / (max - min)) * (2 * Math.PI - 2 * this.initAng) + this.initAng;
        }

        updateValue(val) {
          val = this.normalizeValue(val, this.maxVal, this.minVal);
          const presentAng = this.calcAngle(val, this.maxVal, this.minVal);

          // 数値の表示
          this.present_val.textContent = val.toFixed(1);
          // メーターの扇型の設定
          // d="M{中心座標} L{円弧始め座標} A{半径} {回転角（傾き）} {if 180度以下 0 else 1} {if 反時計回り 0 else 1} {円弧終り座標}z"
          const settings = `M0,0 L${-this.r * Math.sin(this.initAng)},${this.r * Math.cos(this.initAng)} A${this.r},${this.r} 0 ${(presentAng <= (Math.PI + this.initAng)) ? 0 : 1} 1 ${-this.r * Math.sin(presentAng)},${this.r * Math.cos(presentAng)}z`;
          // アニメーションの設定
          // const last_settings = this.arc_animation.getAttribute('to');
          // this.arc_animation.setAttribute('from', last_settings);
          // this.arc_animation.setAttribute('to', settings);

          this.arc.setAttribute('d', settings);
        }
      }
    </script>

    <!-- map.js -->
    <script type="text/javascript">
      // 外部コンテンツの元が HTML の <img> または SVG の <svg> 要素であった場合、キャンバスの内容を取得しようとすることは許可されていません。(https://developer.mozilla.org/ja/docs/Web/HTML/CORS_enabled_image)
      // こっちの方が問題の本質に近そう。要はChromeの設定によってローカル環境の同一フォルダに含まれるファイルは同一Originだとは認識されないらしい。Google様が色々気を使っているらしいが、逆に迷惑。
      // https://www.petitmonte.com/javascript/chrome_securityerror.html
      // https://yujisoftware.hatenablog.com/entry/20100815/1281885412
      // https://www.karakaram.com/mac-google-chrome-option/
      'use strict';

      class Map extends GeneralFuncs {
        constructor(map_node_id = 'map', map_wrapper_node_id = 'map_wrapper', coordinate = { north_lat: 35.86133, sounth_lat: 35.85704, east_lng: 140.24666, west_lng: 140.23635 }, map_img_name = 'ootone.png') {
          super();
          this.map_node_id = map_node_id;
          this.map_wrapper_node_id = map_wrapper_node_id;
          this.map_wrapper_node = document.getElementById(this.map_wrapper_node_id);
          this.coordinate = coordinate; // 地図画像の緯度・経度の範囲
          this.map_img_name = map_img_name;

          // width, height取得
          // 画像の読み込み
          this.map_img = new Image();
          // このJSファイルから読み出されるわけでなく、HTMLファイルからの読み出しになる。（画像要素をDOMに付加するため。）よって相対パスで指定する場合は要注意。
          this.map_img.src = `./img/${this.map_img_name}`;
          this.map_img.onload = this.getWidthAndHeight();
        }

        getWidthAndHeight() {
          // naturalWidth / naturalHeight -> 表示されているサイズではなく、画像の本来のサイズを取得したい場合
          const map_img_natural_width = this.map_img.naturalWidth;
          const map_img_natural_height = this.map_img.naturalHeight;
          const map_img_aspect = map_img_natural_height / map_img_natural_width;

          const map_wrapper_width = this.map_wrapper_node.clientWidth;
          const map_wrapper_height = this.map_wrapper_node.clientHeight;

          const tmp_map_img_height = map_wrapper_width * map_img_aspect; // マップ画像の横幅をwrapperの横幅いっぱいにした際の縦幅
          const tmp_map_img_width = map_wrapper_height * (1 / map_img_aspect); // その逆

          if (tmp_map_img_width > map_wrapper_width) {
            this.width = map_wrapper_width;
            this.height = tmp_map_img_height;
          } else if (tmp_map_img_height > map_wrapper_height) {
            this.width = tmp_map_img_width;
            this.height = map_wrapper_height;
          } else {
            if (map_wrapper_width * tmp_map_img_height > tmp_map_img_width * map_wrapper_height) {
              this.width = map_wrapper_width;
              this.height = tmp_map_img_height;
            } else {
              this.width = tmp_map_img_width;
              this.height = map_wrapper_height;
            }
          }

          this.init();
        }

        init() {
          // ------- 定数 --------
          this.warning_val_range = [{ r: { min: 0, max: 0 }, g: { min: 255, max: 255 }, b: { min: 0, max: 0 }, a: { min: 0, max: 255 } }];
          this.danger_val_range = [{ r: { min: 255, max: 255 }, g: { min: 0, max: 0 }, b: { min: 0, max: 0 }, a: { min: 0, max: 255 } }];

          // ------- map_layer -------
          // canvas要素を取得・設定。
          const canvas = document.querySelector(`#${this.map_node_id} > .map_layer`);
          canvas.width = this.width;
          canvas.height = this.height;
          // 2Dコンテキストの取得
          // this.context = canvas.getContext("2d");

          // 画像の読み込み時に発動
          // this.map_img.onload = function () {....} とした場合、無名関数内のthisはimg要素自体を表す。
          // 一方、有名関数としてそれを呼び出した場合、thisはMapオブジェクト自体を表す。つまり、bindはなくてもよかった。
          this.map_img.onload = this.drawMap();
        }

        // マップの描画
        drawMap() {
          const map_img_width = this.map_img.width;
          const map_img_height = this.map_img.height;
          // drawImageの解説：http://www.htmq.com/canvas/drawImage_s.shtml
          // this.context.drawImage(this.map_img, 0, 0, map_img_width, map_img_height, 0, 0, this.width, this.height);

          // this.context.beginPath();
          // this.context.rect(0, 0, this.width, this.height);
          // this.context.fillStyle = "rgba(0,255,0,0.8)";
          // this.context.fill();

          // this.context.strokeStyle = "purple";
          // this.context.lineWidth = 8;
          // this.context.stroke();

          // ------- points_layer -------
          // svg要素を取得・設定
          const svg = document.querySelector(`#${this.map_node_id} > .points_layer`);
          svg.setAttribute('width', this.width);
          svg.setAttribute('height', this.height);
          // svg.setAttribute('viewBox', `${this.coordinate.west_lng} ${-this.coordinate.north_lat} ${Math.abs(this.coordinate.east_lng - this.coordinate.west_lng)} ${Math.abs(this.coordinate.north_lat - this.coordinate.sounth_lat)}`);
          // 現在値表現のNodeを取得
          this.present_effect = document.querySelector(`#${this.map_node_id} > .points_layer > .present_effect`);
          // 地点表示領域の取得
          this.points = document.querySelector(`#${this.map_node_id} > .points_layer > .points`);
          // 最大表示point数を設定
          this.max_points_num = 100;

          // ----- 表示位置 ------
          const canvas = document.querySelector(`#${this.map_node_id} > .map_layer`);
          const top = this.map_wrapper_node.clientHeight - this.height;
          const left = this.map_wrapper_node.clientWidth - this.width;
          canvas.setAttribute('style', `top: ${top}px; left: ${left}px;`);
          svg.setAttribute('style', `top: ${top}px; left: ${left}px;`);
        }

        // 円の描画
        drawPoint(x, y, r) {
          // 描画座標を計算
          const cx = this.width * ((x - this.coordinate.west_lng) / (this.coordinate.east_lng - this.coordinate.west_lng));
          const cy = this.height * (1 - ((y - this.coordinate.sounth_lat) / (this.coordinate.north_lat - this.coordinate.sounth_lat)));

          const point = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          point.setAttributeNS(null, "cx", x);
          point.setAttributeNS(null, "cy", y);
          // point.setAttributeNS(null, "cy", -y); 本当はこれ
          point.setAttributeNS(null, "r", r);

          // 追加
          this.points.appendChild(point);

          // 現在地点を示す効果を描画
          this.drawCurrentEffect(x, y, 2 * r);
        }

        // 現在地点表現を描画
        drawCurrentEffect(x, y, r) {
          this.present_effect.setAttribute("cx", x);
          this.present_effect.setAttribute("cy", y);
          this.present_effect.setAttribute("r", r);
        }

        updateValue(x, y) {
          console.log(`x:${x}, y:${y}`);
          // 最大表示数を超えたら削除
          if (this.points.children.length >= this.max_points_num)
            this.points.removeChild(this.points.firstChild);

          // 指定座標から幅１、高さ１のImageDataObjectを取得
          // 画像だけでなくcanvas上にある全ての要素も含めピクセル値を調べる
          // const imgdata = this.context.getImageData(x, y, 1, 1);
          // RGBA値を格納
          // const pixel_data = { r: imgdata.data[0], g: imgdata.data[1], b: imgdata.data[2], a: imgdata.data[3] };
          // console.log(pixel_data);
          // this.checkAlert(pixel_data, this.present_effect, this.map_wrapper_node_id, this.danger_val_range, 'map');

          this.drawPoint(x, y, 5);
        }
      }
    </script>

    <!-- posture.js -->
    <script type="text/javascript">
      'use strict';

      class Posture extends GeneralFuncs {
        constructor(posture_node_id) {
          super();
          this.posture_node_id = posture_node_id;
          this.init();
        }

        init() {
          // 表示領域を取得
          const posture_node = document.getElementById(this.posture_node_id);
          const width = posture_node.clientWidth;
          const height = posture_node.clientHeight;

          // scene: ステージ
          this.scene = new THREE.Scene();

          // mesh: 物体
          // - geometry 形状
          // - material 材質
          this.mesh = this.createTriangle(50, 10);
          this.scene.add(this.mesh);

          // light
          // - 平行光源
          const light = new THREE.DirectionalLight(0xffffff, 1); // 色, 強さ
          light.position.set(0, 100, 30);
          this.scene.add(light);
          // - 環境光
          const ambient = new THREE.AmbientLight(0x404040);
          this.scene.add(ambient);

          // camera
          this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 5000);
          this.camera.position.set(200, 200, 300);
          this.camera.lookAt(this.scene.position);

          // helper
          const gridHelper = new THREE.GridHelper(200, 50); // 全体サイズ/1つのグリッドの大きさ
          this.scene.add(gridHelper);

          const axisHelper = new THREE.AxesHelper(1000); // 軸のサイズ
          this.scene.add(axisHelper);

          const lightHelper = new THREE.DirectionalLightHelper(light, 20); //サイズ
          this.scene.add(lightHelper);

          // renderer
          this.renderer = new THREE.WebGLRenderer({ antialias: true });
          this.renderer.setSize(width, height);
          // this.renderer.setClearColor(0xefefef);
          this.renderer.setClearColor(0x000000);
          this.renderer.setPixelRatio(window.devicePixelRatio); //高解像度ディスプレイ向けの設定。これを設定するときれいに表示される。
          posture_node.appendChild(this.renderer.domElement);

          // controls
          this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);

          // shadow
          this.renderer.shadowMap.enabled = true;
          light.castShadow = true;
          light.shadow.camera.left = -200;
          light.shadow.camera.right = 200;
          light.shadow.camera.top = 200;
          light.shadow.camera.bottom = -200;
          const shadowHelper = new THREE.CameraHelper(light.shadow.camera);
          this.scene.add(shadowHelper);

          this.render();
        }

        // 三角柱をつくる。原点は底面正三角形の重心、柱の高さの半分の位置とする。
        // length: 底面の正三角形の辺の長さ
        // height: 三角柱の高さ
        createTriangle(length, height) {

          const faceColor = 0x00ff00;

          const halfHeight = height / 2.0;
          const halfLength = length / 2.0;
          // 正三角形の重心から辺へ下ろした垂線の長さ
          const distanceToLine = halfLength * Math.tan(Math.PI / 6.0);
          // 正三角形の頂点から対辺へ垂線を下ろしたときの、垂線と重心の間の距離
          const distanceFromVertex = halfLength / Math.tan(Math.PI / 6.0) - distanceToLine;

          const vertices = [
            new THREE.Vector3(-halfLength, halfHeight, distanceToLine),   // 上面の三角形の頂点
            new THREE.Vector3(0, halfHeight, -distanceFromVertex),
            new THREE.Vector3(halfLength, halfHeight, distanceToLine),
            new THREE.Vector3(-halfLength, -halfHeight, distanceToLine),   // 下面の三角形の頂点
            new THREE.Vector3(0, -halfHeight, -distanceFromVertex),
            new THREE.Vector3(halfLength, -halfHeight, distanceToLine),
          ];
          const faces = [
            new THREE.Face3(0, 2, 1), // 上面
            new THREE.Face3(3, 4, 5), // 下面
            new THREE.Face3(0, 3, 2), // 手前側面
            new THREE.Face3(2, 3, 5),
            new THREE.Face3(0, 1, 3), // 左側面
            new THREE.Face3(1, 4, 3),
            new THREE.Face3(2, 5, 4), // 右側面
            new THREE.Face3(4, 1, 2),
          ];

          const geometry = new THREE.Geometry();
          for (let i = 0; i < vertices.length; i++) {
            geometry.vertices.push(vertices[i]);
          }
          for (let i = 0; i < faces.length; i++) {
            geometry.faces.push(faces[i]);
          }

          const material = new THREE.MeshBasicMaterial({ color: faceColor });
          // 三角柱のワイヤーフレームを描く
          const wireframeGeometry = new THREE.EdgesGeometry(geometry);
          const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });

          const triangleMesh = new THREE.Mesh(geometry, material);
          const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);

          triangleMesh.add(wireframe);
          return triangleMesh;
        }

        render() {
          // 再起的にrender関数を呼び出すと、毎回thisの中身が変化するので、bindしてあげる。
          requestAnimationFrame(this.render.bind(this)); //ブラウザの描画更新単位で処理を呼び出す。タブがアクティブでないと動作を抑制する。
          this.controls.update();
          this.renderer.render(this.scene, this.camera);
        }

        updateValue(roll, pitch, yaw) {
          this.mesh.rotation.set(roll, pitch, yaw);
        }
      }
    </script>

    <!-- main.js -->
    <script type="text/javascript">
      'use strict';

      let map, alt_barmeter, aspd_tachometer, gspd_tachometer, rpm_tachometer, posture;

      // 画面読み込み完了時に発動
      window.onload = async function () {
        alt_barmeter = new BarMeter('alt_barmeter', 'alt_barmeter_wrapper');
        map = new Map('map', 'map_wrapper');
        aspd_tachometer = new TachoMeter('aspd_tachometer', 'aspd_tachometer_wrapper');
        gspd_tachometer = new TachoMeter('gspd_tachometer', 'gspd_tachometer_wrapper');
        rpm_tachometer = new TachoMeter('rpm_tachometer', 'rpm_tachometer_wrapper');
        posture = new Posture('posture_wrapper');

        setInterval(function () {
          const dataset = createValues();
          updateValues(dataset);
        }, 100);
      };

      // update
      function updateValues(dataset) {
        alt_barmeter.updateValue(dataset.alt);
        map.updateValue(dataset.lng, dataset.lat);
        posture.updateValue(dataset.roll, dataset.pitch, dataset.yaw);
        aspd_tachometer.updateValue(dataset.aspd);
        gspd_tachometer.updateValue(dataset.gspd);
        rpm_tachometer.updateValue(dataset.rpm);
      }

      // updateSize
      function updateNodeSize() {
        alt_barmeter.init();
        map.init();
        // 既に設定されている子要素の削除
        const posture_node = document.getElementById('posture_wrapper');
        const clone = posture_node.cloneNode(false);
        posture_node.parentNode.replaceChild(clone, posture_node);
        posture.init();
        aspd_tachometer.init();
        gspd_tachometer.init();
        rpm_tachometer.init();
      }

      // アラート音設定
      const alert_switch = document.getElementById('alert_switch');
      function audioPlay() {
        if (!GeneralFuncs.is_ok_playing_alert) {
          document.getElementById('warning_sound').play();
          document.getElementById('danger_sound').play();
          GeneralFuncs.is_ok_playing_alert = true;
          alert_switch.innerText = 'Alert OFF';
        } else {
          GeneralFuncs.is_ok_playing_alert = false;
          alert_switch.innerText = 'Alert ON';
        }
      }
      alert_switch.addEventListener('click', audioPlay, false);

      // 全画面表示
      const goFS_node = document.getElementById("goFS");
      function toggleFullScreen() {
        let doc = window.document;
        let docEl = doc.documentElement; // documentのルート要素（HTML文書の場合は<html>）を取得

        // ベンダープレフィックスを付けているが、将来的に要らなくなる可能性あり。
        // あとchromeのHTMLレンダリングエンジンはBlinkになってきているが、ベンダプレフィックスはwebkitのままで良さそう。（BlinkがWebkitの派生だから？）
        let requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        let exitFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

        if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
          // document.documentElement: root要素を取得。この場合はhtml要素。
          // document.documentElement.style.setProperty('--window-width', window.parent.screen.width);
          // document.documentElement.style.setProperty('--window-height', window.parent.screen.height);
          requestFullScreen.call(docEl);
          goFS_node.innerText = "Exit";
          updateNodeSize();
        } else {
          exitFullScreen.call(doc);
          goFS_node.innerText = "Fullscreen";
          updateNodeSize();
        }
      }
      goFS_node.addEventListener('click', toggleFullScreen, false);

      function createValues() {
        let dataset = {};
        dataset.alt = Math.random() * (alt_barmeter.maxVal - alt_barmeter.minVal) + alt_barmeter.minVal;
        // dataset.lat = Math.random() * (map.coordinate.sounth_lat - map.coordinate.north_lat);
        dataset.lat = Math.random() * 387.9;
        // dataset.lng = Math.random() * (map.coordinate.east_lng - map.coordinate.west_lng);
        dataset.lng = Math.random() * 757;
        dataset.roll = Math.random() * Math.PI * 2;
        dataset.pitch = Math.random() * Math.PI * 2;
        dataset.yaw = Math.random() * Math.PI * 2;
        dataset.aspd = Math.random() * (aspd_tachometer.maxVal - aspd_tachometer.minVal) + aspd_tachometer.minVal;
        dataset.gspd = Math.random() * (gspd_tachometer.maxVal - gspd_tachometer.minVal) + gspd_tachometer.minVal;
        dataset.rpm = Math.random() * (rpm_tachometer.maxVal - rpm_tachometer.minVal) + rpm_tachometer.minVal;
        dataset.time = new Date();
        return dataset;
      }
    </script>
  </body>

</html>